## Lession 1 UML

### 类图之间的线
- 继承：实线，子指向父，空心箭头，like "is a"
- 实现：虚线，指向接口，空心箭头。一般实现接口（虚）的方法

- 关联：实线，关系稳定，对象之间有关联。通常一个类中有另外一个类作为属性
- 依赖：虚线。临时用一下，表示使用关系。

- 聚合：空心菱形，一个群体中的一个指聚合。“has a”
- 组合：实心菱形，一个集合中必不可少的一部分指组合。强关系，并有相同的生命周期。“contain a”

### UML时序图

- 同步调用：实线实心箭头
- 异步调用：实线线箭头
- 返回：虚线线箭头

### 类图
#### 第一个框：类名
- 抽象类：斜体
- 接口：两个尖括号，并加interface
#### 第二个框：类的属性
- 前面符号是访问权限控制：+为public，-为private，#为protected，
- 冒号后面指属性的类型
- 属性下面有横线代表static属性 
#### 第三个框：类的行为
- 同上面
- 方法为斜体表示抽象方法

## Lession 2 原则
   根据应用场景选择合适的原则，并不是一定要遵守
### 开闭原则
- 定义：一个软件实体如类／模块／函数指对扩展开放，修改关闭； 用抽象构建框架，用实现扩展细节，为了提高软件的复用性和可维护性。例如：弹性工作制度。


### 依赖倒置
- 定义：高层模块不应该依赖低层模块，两者都应该依赖其抽象。
- 抽象不应该依赖细节，而细节应该依赖抽象。
- 针对接口编程而不是针对实现编程。
- 优点：减小类间的耦合性，提高系统稳定，提高代码可读性和可维护性，降低修改带来的风险。

### 单一职责原则
- 定义：不要存在多个导致类变更的原因。一个类／接口／函数只有一个职责。
- 优点：降低类的复杂度，提高类的可读性和维护性，降低变更的风险。

### 接口隔离原则
- 定义：用多个专用的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。
一个类对一个类的依赖建立在最小的接口上。
建立单一接口，不要建立庞大臃肿的接口。
尽量细化接口，接口中的方法尽量少。
- 原则：适度原则
- 优点：符合高内聚低耦合的设计思想，从而使类有很好的可读性，可扩展性和可维护性。

### 迪米特法则（最少知道原则）
- 定义：一个对象对其他对象保持最小的了解。
尽量降低类与类之间的耦合
- 优点：降低类之间的耦合
- 强调只和朋友说话，不和陌生人说话。出现在成员变量，方法的输入、输出参数中的类称为朋友类，而出现在方法体内部的类不属于朋友类。


### 里氏替换原则

### 合成／复用原则


### 简单工厂

- 由一个工厂对象决定创建出哪一种产品类的实例
- 创建型
- 适用场景：负责创建的对象比较少；客户端只知道传入工厂类的参数，对于如何创建对象并不关心。

- 优点：只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创造细节。
- 缺点：职责相对过重，增加新的产品需要修改工厂类的判断逻辑，违背开闭原则。(可以使用反射来弥补）


### 工厂方法
- 定义：定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。 
- 创建型
- 适用场景：创建对象需要大量重复的代码；客户端不依赖于产品类实例如何被创建、实现等细节；一个类通过其子类来指定创建哪个对象
- 优点：用户只需关心所需产品的对应工厂，无须关心创建细节；加入新的产品符合开闭原则，提高可扩展性；
- 缺点：类的个数容易过多，增加复杂度；增加了系统的抽象性和理解难度

### 抽象工厂
- 定义：抽象工厂模式提供一个创建一系列相关或者相互依赖对象的接口
- 无需指定它们具体的类。
- 创建型
- 适用场景：客户端不依赖于产品类实例如何被创建、实现等细节；强调一系列相关产品的对象一起使用创建对象需要大量重复的代码；提供一个产品类的库，所有产品以同样的接口出现，从而使客户端不依赖于具体实现。
- 优点：具体产品在应用层代码隔离，无须关心创建细节；将一系列的产品族统一到一起创建。
- 缺点：规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口；增加了系统的抽象性和理解难度。

- 产品族和产品等级：见图


### builder

- 定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示；特征：用户只需要指定需要建造的类型就可以得到它们，建造过程及细节不需要知道。

- 创建者

- 适用场景：如果一个对象有非常复杂的内部结构（很多属性）；把复杂对象的创建和使用分离
- 优点：封装性好，创建和使用分离；扩展性好，建造类之间相互独立，一定程度上解耦

- 缺点：会产生多余的builder对象；产品内部发生变化，建造者都要修改，成本较大


- new skill: 链式

### 单例

- 定义：保证一个类仅有一个实例，并提供一个全局访问点
- 创建型

- 适用场景：确保任何情况下都绝对只有一个实例

- 优点：在内存中只有一个实例减少内存开销；可以避免对资源的多重占用；设置全局访问点，严格控制访问

- 缺点：没有接口，扩展困难

- 重点：私有构造器；线程安全！；延迟加载；序列化和反序列化安全；反射攻击

- 实用工具：反编译；内存原理；多线程debug

- 相关模式：工厂模式；享元模式


### 原型

- 定义：指原型实例指定创建对象的类型，并且通过拷贝这些原型创建新的对象。
- 特点：不需要知道任何创建的细节，不调用构造函数
- 创建型

- 适用场景：类初始化消耗较多资源；new产生的一个对象需要非常繁琐的过程，如数据准备、访问权限等；构造函数比较复杂时候；循环体中生产大量对象

- 优点：原型模式的性能比实例化方式要高；简化创建过程
- 缺点：必须配备克隆方法；克隆复杂对象或者克隆出对象进行复杂改造时，容易引入风险；对复杂对象进行深拷贝、浅拷贝应用得当

- 扩展：深克隆/浅克隆，一般都用深克隆

### 外观 facade

- 定义：又称门面模式，提供了一个统一的接口，用来访问子系统中的一群接口

- 外观模式定义了一个高层接口，让子系统更容易使用。
- 结构型
- 适用场景：子系统越来越复杂，增加外观模式提供简单调用接口；构建多层系统结构，利用外观对象作为每层的入口，简化层间调用

- 优点：简化了调用过程，无需了解深入子系统，防止带来风险；减少系统依赖，减少耦合；更好划分访问层次；符合迪米特法则，即最少知道原则；
- 缺点：增加子系统、扩展子系统行为容易引入风险；不符合开闭原则

- 相关设计模式：中介者模式；单例模式；抽象工厂

### 装饰着  decorator
- 定义：在不改变原有对象的基础之上，将功能附加到对象上；提供了比继承更有弹性的替代方案（扩展原有对象功能）
- 结构型
- 适用场景：扩展一个类的功能或给一个类添加附加职责；动态的给一个对象添加功能，这些功能可以再动态的撤销；类爆炸
- 优点：继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能；通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果；符合开闭原则
- 缺点：会出现更多的代码，更多的类，增加程序复杂性；动态装饰时，多层装饰时会更加复杂
- 相关设计模式：代理模式；适配器模式

### 适配器模型

- 定义：将一个类的接口转换成客户期望的另外一个接口；使原本接口不兼容的类可以一起工作。
- 结构型
- 适用场景：已存在的类，其方法和需求不匹配时；并不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品/不同厂家造成功能类似而接口不同情况下的解决方案
- 优点：能提高类的透明性和复用，现有的类复用但不需要改变；目标类和适配器类解耦，提高程序扩展性

- 缺点：编写过程需要全面考虑，可能增加系统复杂性；增加系统代码可读的难度
- 扩展：对象适配器；类适配器

- 相关设计模式：外观模式（定义新接口，而适配器是复用原接口）；


### 享元模式

- 定义：提供了减少对象数量从而改善应用所需的对象结构方式；运用共享技术有效地支持大量细粒度的对象
- 结构型
- 适用场景：用于系统低层的开发，以便解决系统的性能问题；系统有大量相似对象，需要缓冲池的场景

- 优点： 减少对象创建，降低内存中对象数量，降低系统的内存，提高效率；减少内存之外的其他资源占用
- 缺点：关注内外部状态、关注线程安全问题；使系统、程序的逻辑复杂化
 
 - 扩展：内部状态；外部状态

 - 相关设计模式：代理模式；单例模式


### 组合模式

- 定义：将对象组合成树形结构以表示“部分-整体”的层次结构；组合模式使客户端对单个对象和组合对象保持一致的方式处理
- 结构型

- 适用场景：客户端可以忽略组合对象与单个对象的差异时；处理一个树形结构时
- 清楚地定义分层次的复杂对象，表示对象的全部或者部分层次；让客户端忽略了层次的差异，方便对整个层次结构进行控制；简化客户端代码；符合开闭

- 缺点：限制类型时会较复杂；使设计变得更加抽象
- 相关模式：访问者模式；



### 桥接

- 定义：将抽象部分与它的具体实现部分分离，使它们都可以独立地变化；通过组合的方式建立两个类之间联系，而不是继承。
- 结构型

- 适用场景：抽象和具体实现之间增加更多的灵活性；一个类存在两个或者多个独立变化的维度，且这两个或者多个维度都需要独立进行扩展；不希望使用继承，或因为多层继承导致系统类的个数剧增。
- 优点：分离抽象部分及其具体实现部分（通过组合代替继承）；提高了系统可扩展性；符合开闭原则；符合合成复用原则

- 缺点：增加系统理解和设计难度；需要正确识别系统中两个独立变化的维度
- 相关设计模式：组合模式（组合强调部分和整体；桥接强调平行类）；适配器模式（改变已有接口）


### (need further study)代理模式
- 定义：为其他对象提供一种代理，以控制对这个对象的访问；代理对象在客户端和目标对象之间起到中介的作用；
- 适用场景：保护目标对象；增强目标对象
- 优点：能将代理对象与真实被调用的目标对象分离；一定程度降低系统的耦合度，扩展性好；保护目标对象；增强目标对象
- 缺点：代理模式会造成系统设计中类的数目增加；在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢；增加系统复杂度

- 扩展：静态代理；动态代理（接口）；CGlib代理（继承）
- Spring代理选择：当Bean有实现接口，Spring就会用jdk的动态代理；当Bean没有实现接口，spring使用cglib，当然也可以强制使用cglib

- 代理速度对比：cglib；jdk动态代理（快）；
- 相关设计模式：装饰模式（添加功能，而代理是控制访问）；适配器模式


